<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SYJPMOPMH POS - Sales</title>
  <link rel="stylesheet" href="https://storage.googleapis.com/syjpmopmh-pos-web/lib/flatpickr.min.css">
  <link rel="stylesheet" href="https://storage.googleapis.com/syjpmopmh-pos-web/tailwind.css">
  <link rel="stylesheet" href="https://storage.googleapis.com/syjpmopmh-pos-web/styles.css">
  <link rel="icon" href="https://storage.googleapis.com/syjpmopmh-pos-web/favicon.ico">
  <style>
    .module { padding: 1rem; }
    .static-row { display: flex; gap: 1rem; margin-bottom: 1rem; }
    .static-row div { flex: 1; display: flex; flex-direction: column; }
    .dynamic-row { display: flex; gap: 1rem; align-items: center; margin-bottom: 0.5rem; }
    .dynamic-row span { flex: 1; minWidth: 120px; }
    .dynamic-row select, .dynamic-row input { width: 100%; }
    .totals { margin: 1rem 0; }
    .print-sidebar { position: fixed; right: -400px; top: 0; width: 400px; height: 100%; background: white; box-shadow: -2px 0 5px rgba(0,0,0,0.2); transition: right 0.3s; padding: 1rem; }
    .print-sidebar.open { right: 0; }
    .table-container { margin-top: 1rem; }
    .keyword-search { margin-bottom: 1rem; }
    .invalid-field { border: 2px solid red; }
    .notification { position: fixed; top: 1rem; right: 1rem; padding: 1rem; border-radius: 0.25rem; color: white; z-index: 1000; }
    .notification.success { background: green; }
    .notification.error { background: red; }
    .loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; color: white; z-index: 999; }
    .login-container { max-width: 400px; margin: 5rem auto; padding: 2rem; border: 1px solid #ccc; border-radius: 0.5rem; }
    .sales-table { width: 100%; border-collapse: collapse; }
    .sales-table th, .sales-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    .sales-table th { background-color: #f2f2f2; }
    .date-row { background-color: #e6e6e6; font-weight: bold; }
    .date-subtotal { background-color: #f9f9f9; font-weight: bold; }
    .toggle-icon { cursor: pointer; margin-right: 5px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script src="https://storage.googleapis.com/syjpmopmh-pos-web/lib/react.production.min.js"></script>
  <script src="https://storage.googleapis.com/syjpmopmh-pos-web/lib/react-dom.production.min.js"></script>
  <script src="https://storage.googleapis.com/syjpmopmh-pos-web/lib/babel.min.js"></script>
  <script src="https://storage.googleapis.com/syjpmopmh-pos-web/lib/flatpickr.min.js"></script>
  <script src="https://storage.googleapis.com/syjpmopmh-pos-web/lib/dashboardSalesTable.js"></script>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    const { SalesRecentTable, SalesPrintPreview } = window;

    const API_URL = "https://us-central1-myposdata.cloudfunctions.net/sales";

    function App() {
      const [isAuthenticated, setIsAuthenticated] = useState(false);
      const [userEmail, setUserEmail] = useState('');
      const [notification, setNotification] = useState({ message: '', type: '' });
      const [isLoading, setIsLoading] = useState(false);

      useEffect(() => {
        const storedEmail = sessionStorage.getItem('userEmail');
        if (storedEmail) {
          setUserEmail(storedEmail);
          setIsAuthenticated(true);
        }
      }, []);

      const login = async (email, password) => {
        setIsLoading(true);
        try {
          const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'authenticate', email, password })
          });
          const result = await response.json();
          if (result.error) throw new Error(result.error);
          if (result.isAuthenticated) {
            setUserEmail(email);
            setIsAuthenticated(true);
            sessionStorage.setItem('userEmail', email);
            showNotification('Login successful!', 'success');
          } else {
            throw new Error('Invalid email or password');
          }
        } catch (error) {
          showNotification(error.message, 'error');
        } finally {
          setIsLoading(false);
        }
      };

      const logout = () => {
        setIsAuthenticated(false);
        setUserEmail('');
        sessionStorage.removeItem('userEmail');
        showNotification('Logged out successfully!', 'success');
      };

      const showNotification = (message, type) => {
        setNotification({ message, type });
        setTimeout(() => setNotification({ message: '', type: '' }), 5000);
      };

      return (
        <div>
          {notification.message && (
            <div className={`notification ${notification.type}`}>
              {notification.message}
            </div>
          )}
          {isLoading && (
            <div className="loading-overlay">
              Authenticating...
            </div>
          )}
          {isAuthenticated ? (
            <div>
              <div className="flex justify-between p-4 bg-gray-100">
                <h1 className="text-xl font-bold">SYJPMOPMH POS</h1>
                <div>
                  <span className="mr-4">{userEmail}</span>
                  <button
                    onClick={logout}
                    className="bg-red-500 text-white p-2 rounded"
                  >
                    Logout
                  </button>
                </div>
              </div>
              <SalesForm userEmail={userEmail} showNotification={showNotification} />
            </div>
          ) : (
            <LoginForm login={login} />
          )}
        </div>
      );
    }

    function LoginForm({ login }) {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');

      const handleSubmit = (e) => {
        e.preventDefault();
        login(email, password);
      };

      return (
        <div className="login-container">
          <h2 className="text-2xl font-bold mb-4">Login</h2>
          <form onSubmit={handleSubmit}>
            <div className="mb-4">
              <label htmlFor="email" className="block mb-1">Email</label>
              <input
                type="email"
                id="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="border p-2 w-full"
                required
              />
            </div>
            <div className="mb-4">
              <label htmlFor="password" className="block mb-1">Password</label>
              <input
                type="password"
                id="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="border p-2 w-full"
                required
              />
            </div>
            <button
              type="submit"
              className="bg-blue-500 text-white p-2 rounded w-full"
            >
              Login
            </button>
          </form>
        </div>
      );
    }

    function SalesForm({ userEmail, showNotification }) {
      const [salesRows, setSalesRows] = useState([]);
      const [salesPaymentRows, setSalesPaymentRows] = useState([]);
      const [salesItems, setSalesItems] = useState([]);
      const [salesmen, setSalesmen] = useState([]);
      const [paymodes, setPaymodes] = useState([]);
      const [shopNames, setShopNames] = useState([]);
      const [departments, setDepartments] = useState([]);
      const [rmdCstms, setRmdCstms] = useState([]);
      const [lastSalesDate, setLastSalesDate] = useState(null);
      const [isEditMode, setIsEditMode] = useState(false);
      const [currentBillNumber, setCurrentBillNumber] = useState(null);
      const [currentDate, setCurrentDate] = useState(null);
      const [formData, setFormData] = useState({
        date: new Date().toISOString().split('T')[0],
        billNumber: '',
        salesman: '',
        shopName: '',
        department: '',
        mobileNumber: '',
        dueBalanceReceived: '',
        dueBalanceBillNumber: '',
        balanceDue: '',
        deliveryDate: ''
      });
      const [isLoading, setIsLoading] = useState(false);
      const [billNumbers, setBillNumbers] = useState([]);
      const [totalAmount, setTotalAmount] = useState(0);
      const [amountReceived, setAmountReceived] = useState(0);
      const datePickerRef = useRef(null);
      const deliveryDatePickerRef = useRef(null);

      window.salesFormInitialize = (billNumber, date) => {
        setIsEditMode(true);
        setCurrentBillNumber(billNumber);
        setCurrentDate(date);
        setFormData(prev => ({ ...prev, billNumber, date }));
        // Fetch existing data for editing
        fetchSalesData(billNumber, date);
      };

      const fetchSalesData = async (billNumber, date) => {
        setIsLoading(true);
        try {
          const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'getSalesDataByBillNumberAndDate', billNumber, date, userEmail })
          });
          const result = await response.json();
          if (result.error) throw new Error(result.error);
          const { salesData, paymentData } = result;
          if (salesData && salesData.length > 0) {
            setFormData(prev => ({
              ...prev,
              salesman: salesData[0].Salesman || '',
              shopName: salesData[0].Shop_Name || '',
              department: salesData[0].Department || '',
              mobileNumber: salesData[0].Mobile_Number || '',
              dueBalanceReceived: salesData[0].Due_Balance_Received || '',
              dueBalanceBillNumber: salesData[0].Due_Balance_Bill_Number || '',
              balanceDue: salesData[0].Balance_Due || '',
              deliveryDate: salesData[0].Delivery_Date || ''
            }));
            setSalesRows(salesData.map(row => ({
              item: row.Item || '',
              amount: row.Amount || '',
              rmdCstm: row.RMD_CSTM || ''
            })));
            setSalesPaymentRows(paymentData.map(row => ({
              paymode: row.Paymode || '',
              amountReceived: row.Amount_Received || ''
            })));
            updateTotal();
          }
        } catch (error) {
          showNotification(`Error fetching sales data: ${error.message}`, 'error');
        } finally {
          setIsLoading(false);
        }
      };

      useEffect(() => {
        if (datePickerRef.current) {
          flatpickr(datePickerRef.current, {
            dateFormat: 'Y-m-d',
            defaultDate: lastSalesDate || new Date(),
            onChange: (selectedDates, dateStr) => {
              setFormData(prev => ({ ...prev, date: dateStr }));
              setLastSalesDate(dateStr);
              updateTotal();
            }
          });
        }
        if (deliveryDatePickerRef.current) {
          flatpickr(deliveryDatePickerRef.current, {
            dateFormat: 'Y-m-d',
            onChange: (selectedDates, dateStr) => {
              setFormData(prev => ({ ...prev, deliveryDate: dateStr }));
              updateTotal();
            }
          });
        }
      }, [lastSalesDate]);

      useEffect(() => {
        fetchNames();
        addRow();
        addPaymentRow();
      }, []);

      const fetchNames = async () => {
        setIsLoading(true);
        try {
          const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'getNamesForSaleData', userEmail })
          });
          const data = await response.json();
          if (data.error) throw new Error(data.error);
          setSalesItems(data.items || []);
          setSalesmen(data.salesmen || []);
          setPaymodes(data.paymodes || []);
          setShopNames(data.shopNames || []);
          setDepartments(data.departments || []);
          setRmdCstms(data.rmdCstms || []);
          updateDueBalanceBillNumbers();
        } catch (error) {
          showNotification('Failed to load sales data: ' + error.message, 'error');
        } finally {
          setIsLoading(false);
        }
      };

      const updateDueBalanceBillNumbers = async () => {
        setIsLoading(true);
        try {
          const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'getBillNumbersWithPendingBalance', userEmail })
          });
          const data = await response.json();
          if (data.error) throw new Error(data.error);
          setBillNumbers(data || []);
        } catch (error) {
          showNotification('Failed to load bill numbers: ' + error.message, 'error');
        } finally {
          setIsLoading(false);
        }
      };

      const addRow = () => {
        setSalesRows(prev => [...prev, { item: '', amount: '', rmdCstm: '' }]);
      };

      const addPaymentRow = () => {
        setSalesPaymentRows(prev => [...prev, { paymode: '', amountReceived: '' }]);
      };

      const removeRow = (index) => {
        setSalesRows(prev => prev.filter((_, i) => i !== index));
        updateTotal();
      };

      const removePaymentRow = (index) => {
        setSalesPaymentRows(prev => prev.filter((_, i) => i !== index));
        updateTotal();
      };

      const updateRow = (index, field, value) => {
        setSalesRows(prev => prev.map((row, i) => i === index ? { ...row, [field]: value } : row));
        updateTotal();
      };

      const updatePaymentRow = (index, field, value) => {
        setSalesPaymentRows(prev => prev.map((row, i) => i === index ? { ...row, [field]: value } : row));
        updateTotal();
      };

      const updateTotal = () => {
        let totalItems = 0;
        salesRows.forEach(row => {
          if (row.amount) totalItems += Number(row.amount) || 0;
        });
        const dueBalanceReceived = Number(formData.dueBalanceReceived) || 0;
        const balanceDue = Number(formData.balanceDue) || 0;
        let totalReceived = 0;
        salesPaymentRows.forEach(row => {
          if (row.amountReceived) totalReceived += Number(row.amountReceived) || 0;
        });
        const total = totalItems + dueBalanceReceived - balanceDue;
        setTotalAmount(total);
        setAmountReceived(totalReceived);
      };

      const isItemRowFilled = (row) => {
        return row.item && salesItems.includes(row.item) &&
               row.amount && row.rmdCstm && rmdCstms.includes(row.rmdCstm);
      };

      const isDueBalanceGroupFilled = () => {
        return formData.dueBalanceReceived && formData.dueBalanceBillNumber;
      };

      const isBalanceDueGroupFilled = () => {
        return formData.balanceDue && formData.deliveryDate;
      };

      const isPaymentRowFilled = (row) => {
        return row.paymode && paymodes.includes(row.paymode) &&
               row.amountReceived && Number(row.amountReceived) > 0;
      };

      const isCombinationAFilled = () => {
        return salesRows.some(isItemRowFilled) &&
               isDueBalanceGroupFilled() &&
               isBalanceDueGroupFilled() &&
               salesPaymentRows.some(isPaymentRowFilled);
      };

      const isCombinationBFilled = () => {
        return salesRows.some(isItemRowFilled) &&
               isBalanceDueGroupFilled() &&
               salesPaymentRows.some(isPaymentRowFilled);
      };

      const isCombinationCFilled = () => {
        return isDueBalanceGroupFilled() &&
               salesPaymentRows.some(isPaymentRowFilled);
      };

      const isCombinationDFilled = () => {
        return salesRows.some(isItemRowFilled) &&
               isDueBalanceGroupFilled() &&
               salesPaymentRows.some(isPaymentRowFilled);
      };

      const isCombinationEFilled = () => {
        return salesRows.some(isItemRowFilled) &&
               salesPaymentRows.some(isPaymentRowFilled);
      };

      const checkBillNumberDateDuplicate = async (billNumber, date) => {
        try {
          const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'checkBillNumberDateDuplicate', billNumber, date, userEmail })
          });
          const result = await response.json();
          if (result.error) throw new Error(result.error);
          return result.isDuplicate;
        } catch (error) {
          showNotification('Error validating bill number and date: ' + error.message, 'error');
          return true;
        }
      };

      const submit = async () => {
        if (!formData.date || !formData.billNumber || !formData.salesman || !formData.shopName || !formData.department) {
          showNotification('Please fill all required static fields.', 'error');
          return;
        }

        if (!isEditMode) {
          const isDuplicate = await checkBillNumberDateDuplicate(formData.billNumber, formData.date);
          if (isDuplicate) {
            showNotification('This bill number and date combination already exists.', 'error');
            return;
          }
        }

        const isValidCombination = isEditMode
          ? salesPaymentRows.some(isPaymentRowFilled)
          : isCombinationAFilled() || isCombinationBFilled() || isCombinationCFilled() ||
            isCombinationDFilled() || isCombinationEFilled();

        if (!isValidCombination) {
          showNotification('Please fill one of the valid field combinations for submission.', 'error');
          return;
        }

        if (salesRows.length > 0 && !isEditMode) {
          const invalidRows = salesRows.reduce((acc, row, i) => {
            if (!isItemRowFilled(row)) acc.push(i + 1);
            return acc;
          }, []);
          if (invalidRows.length > 0) {
            showNotification(`Please fill all fields in item rows. Invalid rows: ${invalidRows.join(', ')}`, 'error');
            return;
          }
        }

        if (salesPaymentRows.length > 0) {
          const invalidPaymentRows = salesPaymentRows.reduce((acc, row, i) => {
            if (!isPaymentRowFilled(row)) acc.push(i + 1);
            return acc;
          }, []);
          if (invalidPaymentRows.length > 0) {
            showNotification(`Please fill all fields in payment rows. Invalid rows: ${invalidPaymentRows.join(', ')}`, 'error');
            return;
          }
        }

        if (totalAmount !== amountReceived) {
          showNotification('Total Amount and Amount Received must be equal.', 'error');
          return;
        }

        const data = {
          ...formData,
          data: salesRows.filter(isItemRowFilled),
          paymentData: salesPaymentRows.filter(isPaymentRowFilled)
        };

        setIsLoading(true);
        try {
          const response = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: isEditMode ? 'updateSalesData' : 'saveSalesData', data, userEmail })
          });
          const result = await response.json();
          if (result.error) throw new Error(result.error);
          showNotification(`Sales data ${isEditMode ? 'updated' : 'saved'} successfully! Rows saved: ${result.rowsSaved}`, 'success');
          resetForm();
        } catch (error) {
          showNotification(`Error ${isEditMode ? 'updating' : 'saving'} sales data: ${error.message}`, 'error');
        } finally {
          setIsLoading(false);
        }
      };

      const resetForm = () => {
        setIsEditMode(false);
        setCurrentBillNumber(null);
        setCurrentDate(null);
        setFormData({
          date: lastSalesDate || new Date().toISOString().split('T')[0],
          billNumber: '',
          salesman: '',
          shopName: '',
          department: '',
          mobileNumber: '',
          dueBalanceReceived: '',
          dueBalanceBillNumber: '',
          balanceDue: '',
          deliveryDate: ''
        });
        setSalesRows([{ item: '', amount: '', rmdCstm: '' }]);
        setSalesPaymentRows([{ paymode: '', amountReceived: '' }]);
        updateTotal();
      };

      return (
        <div id="sales" className="module max-w-4xl mx-auto p-4">
          <h2 className="text-2xl font-bold mb-4">Sales Data Entry</h2>
          {isLoading && (
            <div className="loading-overlay">
              {isEditMode ? 'Updating sales data...' : 'Saving sales data...'}
            </div>
          )}
          <form id="salesForm" onSubmit={e => e.preventDefault()}>
            <div className="static-row">
              <div>
                <label htmlFor="salesDate" className="block mb-1">Date</label>
                <input
                  type="text"
                  id="salesDate"
                  ref={datePickerRef}
                  value={formData.date}
                  onChange={e => setFormData(prev => ({ ...prev, date: e.target.value }))}
                  required
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <div>
                <label htmlFor="salesBillNumber" className="block mb-1">Bill Number</label>
                <input
                  type="text"
                  id="salesBillNumber"
                  value={formData.billNumber}
                  onChange={async e => {
                    setFormData(prev => ({ ...prev, billNumber: e.target.value }));
                    if (!isEditMode && e.target.value && formData.date) {
                      const isDuplicate = await checkBillNumberDateDuplicate(e.target.value, formData.date);
                      if (isDuplicate) {
                        showNotification('This bill number and date combination already exists.', 'error');
                      }
                    }
                  }}
                  required
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>
            <div className="static-row">
              <div>
                <label htmlFor="salesSalesman" className="block mb-1">Salesman</label>
                <select
                  id="salesSalesman"
                  value={formData.salesman}
                  onChange={e => setFormData(prev => ({ ...prev, salesman: e.target.value }))}
                  required
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">Select</option>
                  {salesmen.map(salesman => (
                    <option key={salesman} value={salesman}>{salesman}</option>
                  ))}
                </select>
              </div>
              <div>
                <label htmlFor="salesShopName" className="block mb-1">Shop Name</label>
                <select
                  id="salesShopName"
                  value={formData.shopName}
                  onChange={e => setFormData(prev => ({ ...prev, shopName: e.target.value }))}
                  required
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">Select</option>
                  {shopNames.map(name => (
                    <option key={name} value={name}>{name}</option>
                  ))}
                </select>
              </div>
            </div>
            <div className="static-row">
              <div>
                <label htmlFor="salesDepartment" className="block mb-1">Department</label>
                <select
                  id="salesDepartment"
                  value={formData.department}
                  onChange={e => setFormData(prev => ({ ...prev, department: e.target.value }))}
                  required
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">Select</option>
                  {departments.map(dept => (
                    <option key={dept} value={dept}>{dept}</option>
                  ))}
                </select>
              </div>
              <div>
                <label htmlFor="salesMobileNumber" className="block mb-1">Mobile Number</label>
                <input
                  type="tel"
                  id="salesMobileNumber"
                  value={formData.mobileNumber}
                  onChange={e => {
                    const value = e.target.value.replace(/[^0-9]/g, '');
                    setFormData(prev => ({ ...prev, mobileNumber: value }));
                    if (value.length > 0 && value.length !== 10) {
                      showNotification('Mobile number should be 10 digits long.', 'error');
                    }
                  }}
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>
            <div id="salesRows">
              <div className="dynamic-row font-bold">
                <span style={{ minWidth: '50px' }}></span>
                <span style={{ flex: 1, minWidth: '120px' }}>Item</span>
                <span style={{ flex: 1, minWidth: '120px' }}>Amount</span>
                <span style={{ flex: 1, minWidth: '120px' }}>RMD/CSTM</span>
                <span></span>
              </div>
              {salesRows.map((row, index) => (
                <div key={index} className="dynamic-row">
                  <span style={{ minWidth: '50px' }}>Row {index + 1}</span>
                  <select
                    className="sales-item-select border p-2 rounded focus:ring-2 focus:ring-blue-500"
                    value={row.item}
                    onChange={e => updateRow(index, 'item', e.target.value)}
                    required
                  >
                    <option value="">Select</option>
                    {salesItems.map(item => (
                      <option key={item} value={item}>{item}</option>
                    ))}
                  </select>
                  <input
                    type="number"
                    step="any"
                    value={row.amount}
                    onChange={e => updateRow(index, 'amount', e.target.value)}
                    onKeyDown={e => {
                      const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '-', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'];
                      if (!allowedKeys.includes(e.key)) e.preventDefault();
                    }}
                    onFocus={e => e.target.select()}
                    placeholder="Amount"
                    className="border p-2 rounded focus:ring-2 focus:ring-blue-500"
                    required
                  />
                  <select
                    className="sales-rmdcstm-select border p-2 rounded focus:ring-2 focus:ring-blue-500"
                    value={row.rmdCstm}
                    onChange={e => updateRow(index, 'rmdCstm', e.target.value)}
                    required
                  >
                    <option value="">Select</option>
                    {rmdCstms.map(rmd => (
                      <option key={rmd} value={rmd}>{rmd}</option>
                    ))}
                  </select>
                  <button
                    type="button"
                    className="sales-remove-row bg-red-500 text-white p-2 rounded hover:bg-red-600"
                    onClick={() => removeRow(index)}
                  >
                    Remove
                  </button>
                </div>
              ))}
            </div>
            <button
              type="button"
              id="salesAddItemRow"
              className="bg-blue-600 text-white p-2 rounded my-4 hover:bg-blue-700"
              onClick={addRow}
            >
              Add Item Row
            </button>
            <div id="payment-row">
              <div className="dynamic-row font-bold">
                <span style={{minWidth: '50px'}}></span>
                <span style={{ flex: 1, minWidth: '120px' }}>Payment Method</span>
                <span style={{ flex: 1, minWidth: '120px' }}>Amount Received</span>
                <span></span>
              </div>
              {salesPaymentRows.map((row, index) => (
                <div key={index} className="dynamic-row">
                  <span style={{ minWidth: '50px' }}>Payment {index + 1}</span>
                  <select
                    value={row.paymode}
                    onChange={e => updatePaymentRow(index, 'paymode', e.target.value)}
                    required
                    className="border p-2 rounded focus:ring-2 focus:ring-blue-500"
                  >
                    <option value="">Select</option>
                    {paymodes.map(paymode => (
                      <option key={paymode} value={paymode}>{paymode}</option>
                    ))}
                  </select>
                  <input
                    type="number"
                    step="any"
                    value={row.amountReceived}
                    onChange={e => updatePaymentRow(index, 'amountReceived', e.target.value)}
                    onKeyDown={e => {
                      const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'Backspace', 'Delete', '-', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'];
                      if (!allowedKeys.includes(e.key)) e.preventDefault();
                    }}
                    onFocus={e => e.target.select()}
                    placeholder="Amount Received"
                    className="border p-2 rounded focus:ring-2 focus:ring-blue-500"
                    required
                  />
                  <button
                    type="button"
                    className="sales-remove-payment-row bg-red-500 text-white p-2 rounded hover:bg-red-600"
                    onClick={() => removePaymentRow(index)}
                  >
                    Remove
                  </button>
                </div>
              ))}
            </div>
            <button
              type="button"
              id="salesAddPaymentRow"
              className="bg-blue-600 text-white p-2 rounded my-4 hover:bg-blue-700"
              onClick={addPaymentRow}
            >
              Add Payment Row
            </button>
            <div className="static-row">
              <div>
                <label htmlFor="salesDueBalanceReceived" className="block mb-1">Due Balance Received</label>
                <input
                  type="number"
                  step="any"
                  id="salesDueBalanceReceived"
                  value={formData.dueBalanceReceived}
                  onChange={e => {
                    setFormData(prev => ({ ...prev, dueBalanceReceived: e.target.value }));
                    updateTotal();
                  }}
                  onKeyDown={e => {
                    const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '-', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'];
                    if (!allowedKeys.includes(e.key)) e.preventDefault();
                  }}
                  onFocus={e => e.target.select()}
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <div>
                <label htmlFor="salesDueBalanceBillNumber" className="block mb-1">Due Balance Bill Number</label>
                <select
                  id="salesDueBalanceBillNumber"
                  value={formData.dueBalanceBillNumber}
                  onChange={e => {
                    setFormData(prev => ({ ...prev, dueBalanceBillNumber: e.target.value }));
                    updateTotal();
                  }}
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                >
                  <option value="">Select</option>
                  {billNumbers.map(bill => (
                    <option key={bill.Bill_Number} value={bill.Bill_Number}>
                      {bill.Bill_Number} ({bill.Date && bill.Date.value ? new Date(bill.Date.value).toISOString().split('T')[0] : 'Unknown'})
                    </option>
                  ))}
                </select>
              </div>
            </div>
            <div className="static-row">
              <div>
                <label htmlFor="salesBalanceDue" className="block mb-1">Balance Due</label>
                <input
                  type="number"
                  step="any"
                  id="salesBalanceDue"
                  value={formData.balanceDue}
                  onChange={e => {
                    setFormData(prev => ({ ...prev, balanceDue: e.target.value }));
                    updateTotal();
                  }}
                  onKeyDown={e => {
                    const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '-', 'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'];
                    if (!allowedKeys.includes(e.key)) e.preventDefault();
                  }}
                  onFocus={e => e.target.select()}
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <div>
                <label htmlFor="salesDeliveryDate" className="block mb-1">Delivery Date</label>
                <input
                  type="text"
                  id="salesDeliveryDate"
                  ref={deliveryDatePickerRef}
                  value={formData.deliveryDate}
                  onChange={e => setFormData(prev => ({ ...prev, deliveryDate: e.target.value }))}
                  className="border p-2 rounded w-full focus:ring-2 focus:ring-blue-500"
                />
              </div>
            </div>
            <button
              type="button"
              id="salesSubmit"
              className="bg-green-600 text-white p-2 rounded w-full my-4 hover:bg-green-700"
              onClick={submit}
            >
              {isEditMode ? 'Update' : 'Submit'}
            </button>
            <div className="totals">
              <div id="salesTotalAmount" className="font-bold">Total Amount: {totalAmount.toFixed(2)}</div>
              <div id="salesAmountReceived" className="font-bold">Amount Received: {amountReceived.toFixed(2)}</div>
            </div>
            <div className="table-container">
              <SalesRecentTable userEmail={userEmail} showNotification={showNotification} />
            </div>
            <button
              type="button"
              id="salesPrintBtn"
              className="bg-gray-500 text-white p-2 rounded my-4 hover:bg-gray-600"
              onClick={() => document.getElementById('salesPrintSidebar').classList.toggle('open')}
            >
              Print Preview
            </button>
            <div id="salesPrintSidebar" className="print-sidebar">
              <SalesPrintPreview sales={userEmail} showNotification={showNotification} />
              <button
                id="salesPrint"
                className="bg-blue-600 text-white p-2 rounded w-full mt-4 hover:bg-blue-700"
                onClick={() => {
                  const printContent = document.getElementById('salesPrintPreview').innerHTML;
                  const printWindow = window.open('', '_blank');
                  printWindow.document.write(`<html><head><title>Print</title></head><body>${printContent}</body></html>`);
                  printWindow.document.close();
                  printWindow.print();
                }}
              >
                Print
              </button>
            </div>
          </form>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>